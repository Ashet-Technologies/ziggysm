//!
//! This driver implements a generic PS/2 device which can be either
//! a keyboard or a mouse.
//!
//! The driver performs device auto-detection and auto-configuration.
//!
const std = @import("std");
const ashet = @import("../../main.zig");
const ps2 = @import("ps2.zig");

const logger = std.log.scoped(.generic_ps2);

const Driver = ashet.drivers.Driver;
const Deadline = ashet.time.Deadline;

const Generic_PS2_Device = @This();

const KeyUsageCode = ashet.abi.KeyUsageCode;

driver: Driver = .{
    .name = "Generic PS/2 Device",
    .class = .{
        .input = .{
            .pollFn = poll,
        },
    },
},

input: *StreamSource,
output: *StreamSink,

const IO_Error = error{ NoAcknowledge, Timeout, DeviceError };

fn poll(driver: *Driver) void {
    const dev: *Generic_PS2_Device = @fieldParentPtr("driver", driver);
    _ = dev;
}

pub fn init(
    input: *StreamSource,
    output: *StreamSink,
) Generic_PS2_Device {
    return .{
        .input = input,
        .output = output,
    };
}

$suspender write_byte(data: u8, timeout: Deadline) error{Timeout}!void;
$suspender read_byte(timeout: Deadline) error{Timeout}!u8;

$statemachine PS2(dri: *Generic_PS2_Device) (error{NoDevice, UnknownDevice} || IO_Error)!void
{
    logger.debug("reset device...", .{});
    $call write_command(.reset, .from_ms(1000)) -> $state reset_result;
    ${reset_result} catch |err| switch (err) {
        error.Timeout => return error.NoDevice,
        error.NoAcknowledge, error.DeviceError => |e| return e,
    };

    $yield $try read_byte(.from_ms(1000)) -> $state reset_resp;
    logger.debug("response to reset: 0x{X:0>2}", .{${reset_resp}});

    $call drain(.from_ms(10));

    logger.debug("detect device type...", .{});
    $call $try detect_device_type(.from_ms(1000)) -> $state maybe_device_type;
    if(${maybe_device_type} == null) {
        logger.err("could not determine device type!", .{});
        return error.UnknownDevice; // TODO: Restart the state machine here after a certain timeout
    }
    $state device_type: ps2.DeviceType = ${maybe_device_type}.?;

    logger.info("detected PS/2 device of type {}", .{${device_type}});

    $if (${device_type}.isMouse()) {
        $jump handle_mouse(${dri});
    }
    $if (${device_type}.isKeyboard()) {
        $jump handle_keyboard(${dri});
    }
    logger.err("unsupported device type: {}", .{${device_type}});
}

$submachine handle_mouse(dri: *Generic_PS2_Device) IO_Error!void {
    $state init_deadline: Deadline = .from_ms(2500);

    $call $try write_command(.set_defaults, ${init_deadline});
    $call $try write_command(.enable_scanning, ${init_deadline});

    // TODO: Here, we should switch over to interrupt driven mode on x86!

    $state decoder: ps2.MouseDecoder = .{};

    $while (true) {
        $yield $try read_byte(.infinite) -> $state byte;

        ${decoder}.push(${byte}) catch |err| switch (err) {
            // can't overrun as we push one byte, and process all generated
            // events. a single byte can only generate up to 3 events and the
            // queue is 4 events long.
            error.Overrun => unreachable,
        };

        while (${decoder}.pull()) |event| {
            logger.debug("mouse event: {}", .{event});
            ashet.input.push_raw_event(event);
        }
    }
}

$submachine handle_keyboard(dri: *Generic_PS2_Device) IO_Error!void {
    $state byte: u8 = 0;

    $state init_deadline: Deadline = .from_ms(3000);

    $call $try write_command(.set_defaults, ${init_deadline});

    $call $try write_command(Keyboard.select_scancode_set, ${init_deadline});

    $yield $try write_byte(0x01, ${init_deadline}); // select scancode set 1

    $call $try write_command(Keyboard.select_scancode_set, ${init_deadline});

    $yield $try write_byte(0x00, ${init_deadline}); // get scancode set
    
    $state scancode_ack: u8 = 0;
    $yield $try read_byte(${init_deadline}) -> ${scancode_ack};
    $if (${scancode_ack} != 0xFA) {
        logger.warn("scancode set query failed: 0x{X:0>2}", .{${scancode_ack}});
        $loop {
            $yield $try read_byte(.infinite) -> ${byte};
            logger.warn("unsupported keyboard byte 0x{X:0>}", .{${byte}});
        }
    }

    $yield $try read_byte(${init_deadline}) -> $state scancode_set;
    logger.info("keyboard uses active scancode set: 0x{X:0>2}", .{${scancode_set}});

    $if(${scancode_set} == 1)
    {
        $jump handle_keyboard_sm1(${dri});
    }

    $if(${scancode_set} == 2)
    {
        $jump handle_keyboard_sm2(${dri});
    }

    $if(${scancode_set} == 3)
    {
        return error.UnsupportedScanCode;
    }

    logger.warn("unsupported scancode set: 0x{X:0>2}", .{${scancode_ack}});
    $while (true) {
        $yield $try read_byte(.infinite) -> ${byte};
        logger.warn("unsupported keyboard byte 0x{X:0>}", .{${byte}});
    }
}

$submachine handle_keyboard_sm1(dri: *Generic_PS2_Device) IO_Error!void {
    $state decoder: ps2.KeyboardDecoderSCS1 = .{};
    $while (true) {
        $yield $try read_byte(.infinite) -> $state byte;

        ${decoder}.push(${byte}) catch |err| switch (err) {
            // can't overrun as we push one byte, and process all generated
            // events. a single byte can only generate up to 1 event and the
            // queue is 4 events long.
            error.Overrun => unreachable,
        };

        while (${decoder}.pull()) |event| {
            logger.debug("keyboard event: {}", .{event});
            ashet.input.push_raw_event(event);
        }
    }
}


$submachine handle_keyboard_sm2(dri: *Generic_PS2_Device) IO_Error!void {
    $state decoder: ps2.KeyboardDecoderSCS2 = .{};
    $while (true) {
        $yield $try read_byte(.infinite) -> $state byte;

        ${decoder}.push(${byte}) catch |err| switch (err) {
            // can't overrun as we push one byte, and process all generated
            // events. a single byte can only generate up to 1 event and the
            // queue is 4 events long.
            error.Overrun => unreachable,
        };

        while (${decoder}.pull()) |event| {
            logger.debug("keyboard event: {}", .{event});
            ashet.input.push_raw_event(event);
        }
    }
}

$proc drain(timeout: Deadline) void {
    $loop {

        $yield read_byte(${timeout}) -> $state read_result;

        $if(${read_result} == error.Timeout) {
            $return;
        }
        
        if (${read_result}) |byte| {
            logger.debug("draining 0x{X:0>2}", .{byte});
        } else |err| switch (err) {
            error.Timeout => unreachable,
        }
    }
}

$proc detect_device_type(timeout: Deadline) !?ps2.DeviceType {
    $call $try write_command(.disable_scanning, ${timeout});
    $call $try write_command(.identify, ${timeout});

    $yield read_byte(${timeout}) -> $state lo_err;
    $state lo: u8 = ${lo_err} catch return null;    

    $yield read_byte(${timeout}) -> $state hi_err;
    $state hi: u8 = ${hi_err} catch 0x00;

    $state device_id: ps2.DeviceType = std.mem.readInt(u16, &.{ ${lo}, ${hi} }, .little);

    $return @enumFromInt(${device_id});
}

$proc write_command(cmd: Command, timeout: Deadline) IO_Error!void {
    $state count: usize = 0;
    $while(${count} < 3) {
        logger.debug("write {}", .{${cmd}});
        $yield $try write_byte(@intFromEnum(${cmd}), ${timeout});

        $yield $try read_byte(${timeout}) -> $state response_data;

        $state response: Response = @enumFromInt(${response_data});
        logger.debug("  got {}", .{${response}});

        $if (${response} == .ack) {
            $return;
        }
        $if (${response} != .resend) {
            $return error.NoAcknowledge;
        }

        ${count} += 1;
    }

    // This is actually a device error as we didn't receive either ACK or RESEND, but we also didn't timeout
    $return error.DeviceError;
}

pub const Command = enum(u8) {
    identify = 0xF2,
    enable_scanning = 0xF4,
    disable_scanning = 0xF5,
    set_defaults = 0xF6,
    resend = 0xFE,
    reset = 0xFF,

    _,
};

pub const Response = enum(u8) {
    ack = 0xFA,
    resend = 0xFE,

    _,
};

const Keyboard = struct {
    pub const set_leds: Command = @enumFromInt(0xED);
    pub const selftest: Command = @enumFromInt(0xEE); // returns 0xEE
    pub const select_scancode_set: Command = @enumFromInt(0xF0);
    pub const set_repeat_rate: Command = @enumFromInt(0xF3);
};

const Mouse = struct {
    pub const set_resolution: Command = @enumFromInt(0xE8);
    pub const status_request: Command = @enumFromInt(0xE9);
    pub const request_single_packet: Command = @enumFromInt(0xEB);
    pub const get_mouse_id: Command = @enumFromInt(0xF2);
    pub const set_sample_rate: Command = @enumFromInt(0xF3);
};

// TODO: Refactor sink/source and move them elsewhere:

pub const StreamSink = struct {
    write_fn: *const fn (*StreamSink, []const u8, Deadline) error{Timeout}!void,

    pub fn write(sink: *StreamSink, data: []const u8, deadline: Deadline) error{Timeout}!void {
        return sink.write_fn(sink, data, deadline);
    }
};

pub const StreamSource = struct {
    read_available_fn: *const fn (*StreamSource, []u8) usize,
    // TODO: Introduce a read_all_fn which takes a deadline for more efficient backing impls

    pub fn read_available(source: *StreamSource, data: []u8) usize {
        return source.read_available_fn(source, data);
    }

    pub fn read_all(source: *StreamSource, data: []u8, deadline: Deadline) error{Timeout}!void {
        var offset: usize = 0;
        while (offset < data.len) {
            const len = source.read_available(data[offset..]);
            offset += len;
            if (offset == data.len)
                break;

            try deadline.check();

            ashet.scheduler.yield(); // TODO: Is this okay?
        }
    }
};
